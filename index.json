[{"categories":["JS學習"],"contents":"什麼是 IIFE? 是一個定義完馬上就執行的 JavaScript function\n有什麼功能 不需要呼叫此函式，也能在函式建立後立即執行。 可以減少「全域變數」的產生，同時也避免了變數名稱衝突的機會 一般函示需要呼叫才會執行\nfunction getNumber() { var value = 2; return value; } console.log(getNumber()); // 2 IIFE 只要在 function 外加上()，並在 function 後加上()就可以不需呼叫，就可以執行\n(function () { var value = 2; console.log(value); // 2 })(); 用箭頭函示更簡化\n(() =\u0026gt; { var value = 2; console.log(value); // 2 })(); (function () { var value = 2; console.log(value); // 2 })(); //數字2只能在在裡面印出，外層無法取得 除非： console.log( (function () { var value = 2; return value; })() ); // 2 或者是： let number = (function () { var value = 2; return value; })(); console.log(number); // 2 //用number變數去接值 以 setTimeout()來說明 for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // 3,3,3 }, i * 1000); } for 迴圈已跑完，setTimeout 才開始要執行，當執行要抓 i 時 i 已變成 3\nfor (var i = 0; i \u0026lt; 3; i++) { (function (i) { setTimeout(() =\u0026gt; { console.log(i); //0,1,2 }, 1000 * i); })(i); } 用 IIFE 就可以把 i 當參數傳入並一起跑到 web apis 排隊印出。\n但 ES6 以後有了 let、const 變數的加入只要把變數改為 let 就算不使用 IIFE 也會有同樣的效果，造成這樣的原因則是閉包。閉包說明\nfor (let i = 0; i \u0026lt; 3; i++) { //Closure 閉包 setTimeout(() =\u0026gt; { console.log(i); //0,1,2 }, i * 1000); } ","permalink":"https://LunaZhuang.github.io/blog/js-iife/","tags":["JavaScript"],"title":"JavaScript-立即呼叫(IIFE)"},{"categories":["JS學習"],"contents":"什麼是閉包？ 閉包是一種資料結構，包含函式以及該函式被宣告時所建立的環境組合，因此當函式是在其宣告的語彙範疇之外執行時也能正常運作。\n在說閉包以前先來複習範圍練\nfunction outside() { let a = 1; function inside() { console.log(a); } inside(); } outside(); //1 在inside()這個函示裡是沒有 a 變數，因為沒有他會向外尋找，在上一層找到 a 變數就停止，假設在上一層也沒有就會再往外一層去做尋找，直到在全域裡也找不到，就會回傳 not defined。\n有使用閉包與沒使用閉包的差別 沒使用閉包 var count = 0; function number() { return ++count; } console.log(number()); console.log(number()); console.log(number()); 當我想要累加時會用一個全域變數來儲存，但當時用 var 就有可能會影響到其他程式碼，並造成錯誤。 如果我用 let，因為 let 是 block scope{}，出去{}後就會消失數字也不會累加上去，永遠都會是１。\n有使用閉包 function number() { let count = 0; function times() { return ++count; } return times; } let witch = number(); let witch2 = number(); console.log(witch()); //1 console.log(witch()); //2 console.log(witch()); //3 console.log(witch2()); //1 console.log(witch2()); //2 像這樣使用閉包就算不用 let 宣告變數，也不用擔心 var 變數會污染到，不是這個函式的其他程式碼，因為範圍練不在上一層找不到，所以不會影響。而且 let 變數也因為閉包而不會消失，而是可以繼續累加，使用閉包還可以使不同物件的累加不會相互影響。\nfunction number() { let count = 0; return () =\u0026gt; ++count; } let witch = number(); let witch2 = number(); console.log(witch()); //1 console.log(witch()); //2 console.log(witch()); //3 console.log(witch2()); //1 console.log(witch2()); //2 還可以搭配箭頭函示使程式碼更簡短。\nsetTimeout()產生的閉包 同樣的函式let與var的會產生不同的結果\nfor (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; { console.log(i); // 3,3,3 }, i * 1000); } 因為 var 是全域變數，是屬於 function socpe，這個變數會一直在，所以不會產生閉包，要等 stack 清空排隊的資料才會上去，等到時候 i 已變成 3。\nfor (let i = 0; i \u0026lt; 3; i++) { //Closure 閉包 setTimeout(() =\u0026gt; { console.log(i); //0,1,2 }, i * 1000); } 因為 i 是用 let 宣告是屬於 block socpe 所以如果等到迴圈跑完，我 i 都不見了，為了防止 i 不見會把 i 包起來一起跑到 web apis 排隊印出。\n","permalink":"https://LunaZhuang.github.io/blog/js-closures/","tags":["JavaScript"],"title":"JavaScript-閉包(Closures)"},{"categories":["JS學習"],"contents":"什麼是正規表達式(RegExp)? 是電腦科學的一個概念。正規表示式使用單個字串來描述、符合一系列符合某個句法規則的字串。在很多文字編輯器裡，正規表達式通常被用來檢索、替換那些符合某個模式的文字。\n正則表達式中的特殊字符 常用 MDN 詳細介紹\n範例 我在左下的身份字號中要找出哪些有符合規定，當我要搜尋字串時要/ / 開頭，上方/[A-Z][12]\\d{8}/是我下的規範，其中的[A-Z]代表我第一個字符設定在大寫Ａ到Ｚ，[12]我第二個字符設定在數字 1 與 2 判定男女，\\d{8}我餘下的字符都是數字並有 8 個數字。\n可以到此網址試試看\n","permalink":"https://LunaZhuang.github.io/blog/js-regexp/","tags":["JavaScript"],"title":"JavaScript-正規表達式(RegExp)"},{"categories":["其他學習"],"contents":"什麼是 TDD? 是一種開發流程，觀念是「先寫測試，在進入開發工作」。在進行開發工作以前，編寫測試，預先模擬欲測試的情境。\n為什麼要寫 TDD? 預防發生錯誤能馬上知道在哪?\n1.測試本身就是規格\n2.寫出更有信心的程式碼\n3.可以做出比較好的設計\n4.將來有重構的可能性\n如何寫 TDD? 添加測試 增加新功能首先要編寫一個測試，如果滿足該功能的規範則通過該測試。 可以通過詢問來發現這些規範。 測試驅動開發的一個關鍵好處是它使開發人員在編寫代碼之前專注於需求。 運行所有測試。預期新測試應該失敗(紅燈) 表明所需的功能實際上需要新代碼。 只會有一件事最多兩件事，不要讓測試複雜 驗證測試工具是否正常工作。 排除了新測試存在缺陷並始終通過的可能性。 編寫通過新測試的最簡單的代碼(綠燈) 不優雅或硬代碼是可以接受的，只要它通過了測試。 現在所有測試都應該通過了 如果有任何失敗，則必須修改新代碼，直到它們通過。 這可確保新代碼滿足測試要求並且不會破壞現有功能。 根據需要進行重構，在每次重構後使用測試來確保保留功能 代碼被重構以提高可讀性和可維護性。 優化程式碼，包含產品程式和測試程式（測試程式也是專案需維護的一部份）。 同時確保每次修改後，執行測試皆能通過。 每個新功能重複 1~3 動作，到最後 4 的所有功能測試都通過就是 TDD\n範例 首先我對這個功能有以下的規範：\n存錢功能：\n可以存錢 不可以存 0 元或是小於 0 元的金額（越存錢越少！） 領錢功能:\n可以領錢 不能領 0 元或是小於 0 元的金額（越領錢越多！） 不能領超過本身餘額 1.添加測試:首先我對可以存錢功能，只有開新帳戶有初始錢還有我存錢的錢，以及我餘額會有多少\ntest(\u0026#34;可以存錢\u0026#34;, () =\u0026gt; { const account = new BankAccount(5); account.deposit(10); expect(account.balance).toBe(15); }); 2.運行所有測試。預期新測試應該失敗(紅燈) 3.編寫通過新測試的最簡單的代碼(綠燈):以我測試想要的結果寫出有 constructor 帶進我開戶有的初始值，以及 deposit 存錢的函示，還有 balance 餘額的函示\nclass BankAccount { //初始化帶值要用constructor constructor(accountBalance) { this.accountBalance = accountBalance; } deposit(money) { this.accountBalance += money; } //因為要的是function的回傳值，而不是function本身，所以要有get get balance() { return this.accountBalance; } } 接者重複 1~3 來做餘下的功能\ntest(\u0026#34;不可以存 0 元或是小於 0 元的金額(越存錢越少！)\u0026#34;, () =\u0026gt; { const account = new BankAccount(5); account.deposit(-10); expect(account.balance).toBe(5); }); class BankAccount { constructor(accountBalance) { this.accountBalance = accountBalance; } deposit(money) { if (money \u0026gt; 0) { this.accountBalance += money; } } get balance() { return this.accountBalance; } } test(\u0026#34;領錢功能\u0026#34;, () =\u0026gt; { const account = new BankAccount(20); const money = account.withDraw(5); expect(account.balance).toBe(15); expect(money).toBe(5); }); class BankAccount { constructor(accountBalance) { this.accountBalance = accountBalance; } deposit(money) { if (money \u0026gt; 0) { this.accountBalance += money; } } withDraw(money) { this.accountBalance -= money; return money; } get balance() { return this.accountBalance; } } test(\u0026#34;不能領 0 元或是小於 0 元的金額(越領錢越多！)\u0026#34;, () =\u0026gt; { const account = new BankAccount(20); const money = account.withDraw(-30); expect(account.balance).toBe(20); expect(money).toBe(0); }); class BankAccount { constructor(accountBalance) { this.accountBalance = accountBalance; } deposit(money) { if (money \u0026gt; 0) { this.accountBalance += money; } } withDraw(money) { if (money \u0026gt; 0) { this.accountBalance -= money; return money; } else { return 0; } } get balance() { return this.accountBalance; } } test(\u0026#34;不能領超過本身餘額\u0026#34;, () =\u0026gt; { const account = new BankAccount(20); const money = account.withDraw(30); expect(account.balance).toBe(20); expect(money).toBe(0); }); class BankAccount { constructor(accountBalance) { this.accountBalance = accountBalance; } deposit(money) { if (money \u0026gt; 0) { this.accountBalance += money; } } withDraw(money) { if (money \u0026gt; 0 \u0026amp;\u0026amp; this.accountBalance \u0026gt; money) { this.accountBalance -= money; return money; } else { return 0; } } get balance() { return this.accountBalance; } } 4.現在所有測試都應該通過了也就代表完成 TDD 測試，至於 5 的重構則要看專案是否有時間以及必要進行重構，這都要看每間公司的決定。\n","permalink":"https://LunaZhuang.github.io/blog/tdd/","tags":null,"title":"TDD(測試驅動開發)"},{"categories":["JS學習"],"contents":"什麼是 this? this 是全域物件，在瀏覽器叫 window，在 node 叫 global。\nthis 說明 誰呼叫，誰就是 this ， 沒有明確呼叫者 this 就是 window 在 JavaScript 裡 this 寫在哪沒有關係，跟怎麼執行有關。\nconst hero = { name: \u0026#34;kk\u0026#34;, power: 100, attack: function () { console.log(this); //即使寫在這，也不知道是什麼 }, }; hero.attack(); //{name:\u0026#34;kk\u0026#34;,power:100,attack:[Function:attack]} //hero呼叫，所以this就是hero function hi() { console.log(this); } hi(); //沒有明確呼叫者，就是window 箭頭函示沒有自己的 this，this 等於 window，就算有明確的呼叫者 const hero = { name: \u0026#34;kk\u0026#34;, power: 100, attack: () =\u0026gt; { console.log(this); }, }; hero.attack(); //箭頭函示-\u0026gt;window 有沒有用 new，有用 new,this 就是{ } function hero(name, power) { this.name = name; this.power = power; } const h1 = hero(\u0026#34;kk\u0026#34;, 100); //沒有明確呼叫hero，this是window const h1 = new hero(\u0026#34;kk\u0026#34;, 100); //this是{ } 是否有使用 apply、call、bind，有的話 this 會轉向 const hero = {power:100} function hi(){ console.log(this) } hi.apply(hero)//{power:100},會把hero當this帶進來 hi.call(hero)//{power:100},會把hero當this帶進來 const new_hi = hi.bind(hero); //會回傳一個新的function，不會馬上執行 new_hi()//{power:100} hi.bind(hero)(); //{power:100}，後面加上()會馬上執行IIFE **apply與call差別** const hero = {power:100} function hi(msg){ console.log(msg) console.log(this) } hi.apply(hero,[123])//123，逗號後是參數,apply參數要用陣列包 //{power:100} hi.call(hero,123)//123，逗號後是參數 //{power:100} 是否有使用嚴格模式\u0026quot;use strict\u0026quot;，(可以放在檔案上面或是 function 裡面) \u0026#34;use strict\u0026#34;; function hi() { console.log(this); } hi(); //undefined，不會是window ","permalink":"https://LunaZhuang.github.io/blog/js-this/","tags":["JavaScript"],"title":"JavaScript-this代名詞"},{"categories":["JS學習"],"contents":"什麼是呼叫堆疊(Call Stack) 程式執行的過程是先進後出(FILO)以下圖為說明：\n何謂 Event Loop 有些 function 是需要等待的，JavaScript 會用非同步來處理，其實這些 function 已完成只是先丟到 web api，等到時間到了再丟到 queue 排隊，如果堆疊區有 function 要處理，要等堆疊區無事，queue 裡排隊的 function 才會被丟出來。\n可以到這個網址有更清晰的動畫說明 ","permalink":"https://LunaZhuang.github.io/blog/js-eventloop/","tags":["JavaScript"],"title":"JavaScript-Event Loop"},{"categories":["JS學習"],"contents":" 物件 什麼是物件？ 物件 object = 一個東西＝屬性＋行為\n建立與使用物件 let hero = { //key = power,age //value = 100,20 power: 100, age: 20, attack: function () { console.log(\u0026#34;hi\u0026#34;); }, }; console.log(hero); //{ power: 100, age: 20 } console.log(hero.age); //20 修改、新增、刪除 相比於 Ruby，JavaScript 在物件上可以在外部直接進行，舉例如下\nlet hero = { power: 100, age: 20, attack: function () { console.log(\u0026#34;hi\u0026#34;); }, }; //修改 hero.age = 18; console.log(hero.age); //18 //新增屬性,要小心使用 hero.hello = 124; console.log(hero); //{ power: 100, age: 18, attack: [Function: attack], hello: 124 } //刪除屬性 delete hero.age; console.log(hero); //{ power: 100, attack: [Function: attack], hello: 124 } 其他使用 1.當外部宣告的變數與常數與與物件裡的 key 同名時\nconst age = 18; const attack = () =\u0026gt; { console.log(\u0026#34;hi\u0026#34;); }; let hero = { power: 100, age, //只寫一個代表key與value是一樣的命名，但外面要有同名的宣告變數或常數 attack, }; 用解構取出物件所有資料 const obj = { power: 100, age: 123, }; const { age, power } = obj; //解構(拆解)=\u0026gt;常用 console.log(age); console.log(power); //把上面名為obj的物件拆解後指定給另一個{age,power}常數 //因為{age,power}常數與裡面有同名的key，所以可以直接把資料印出來 物件導向 在 JavaScript 裡，所有物件都有__proto__ const hero = { name: \u0026#34;kk\u0026#34;, power: 100, }; 從上兩張圖可知，我們創建的物件本身只有 key 與 value 沒有方法，是透過 ＿proto__裡的方法借來使用，不需要完整的打完hero.__proto__.toString()只要hero.toString()就可以使用該方法。\nObject.create()使用現有對像作為新創建對象的原型*(以此來做更一步的說明)* //創建了一個新物件 const hero = { name: \u0026#34;kk\u0026#34;, power: 100, }; //以hero物件，為a物件的原型 const a = Object.create(hero); 單看 a 裡面是空物件，但每個物件都有__proto__，所以從a.__proto__中可以看到我所創建的 hero 物件，所以當使用Object.create()其實是將此物件加進ㄏ，使後來創建的物件可以使用該物件，即使後來創建的物件沒有該內容或方法。\n所有 function 都有 prototype function heroCreator(name, power) { //this-\u0026gt;{}有new會做 this.name = name; this.power = power; //return this會自動回傳 } const h1 = new heroCreator(\u0026#34;kk\u0026#34;, 100); //有new會創建一個空物件，有物件就有__proto__，物件導向 const h2 = heroCreator(\u0026#34;kk\u0026#34;, 100); //沒有new是function，沒有回傳值不會回傳東西 console.log(h1); //name:kk,power:100 console.log(h2); //undefined heroCreator.prototype.attack = function () { console.log(1111); }; 我創建了一個 function，所有 function 都有 prototype，當我用 new 時會創建一個空物件，該物件的__proto__在這個時候會自動轉向prototype，所以在 prototype{ }加上行為，__proto__也可找得到，等於 ruby 的開放類別，我可以在原有的類別加上方法。\nEs6 後新增了語法糖衣 class class heroCreator { constructor(name, power) { this.name = name; this.power = power; } attack() { console.log(\u0026#34;attack!!\u0026#34;); } } const h1 = new heroCreator(\u0026#34;kk\u0026#34;, 100); console.log(h1); //heroCreator { name: \u0026#39;kk\u0026#39;, power: 100 } h1.attack(); //attack!! 從 Es6 後的物件導向會以此為主要寫法。\n","permalink":"https://LunaZhuang.github.io/blog/js-object/","tags":["JavaScript"],"title":"JavaScript-物件(Object)與物件導向"},{"categories":["Ruby基本功"],"contents":"為什麼要用模組 class 繼承 class 的方法不就好了？為什麼還要有模組？ 因為你只是想要類別裡的其中一個方法，但為了這方法就要繼承這個類別裡的所有方法，這有點過本末倒置。\n定義與使用模組 模組的命名規定必須是常數常數必須要是大寫英文字母開頭\ninclude:作用在實體方法\nmodule Flyable #定義 def fly puts \u0026#34;fly\u0026#34; end end class Cat include Flyable #引進 end kitty = Cat.new kitty.fly #使用 #因為Cat這個類別有引進Flyable這個模組，所以也可以使用fly方法 extend:作用在類別方法\nmodule Flyable #定義 def fly puts \u0026#34;fly\u0026#34; end end class Cat extend Flyable #在類別裡擴充 end Cat.fly #類別方法 模組與類別的差異 模組沒有繼承的功能，所以不能 module Flyable \u0026lt; SomeModule 模組不能實體化，所以不能 kitty = Flyable.new 在 Ruby 裡冒號位置的意思 冒號在左 has_many :name 是符號 冒號在右 {name: \u0026quot;lily\u0026quot;, age: 18} 是 hash 的 key 冒號在中間,中間有留白 {direction: :up, power: 53} 前面是 key 後面是符號 冒號在中間,中間沒有留白 class User \u0026lt; ActiveRecord::Base User 是繼承 ActiveRecord 模組裡有個叫 Base 的類別 ","permalink":"https://LunaZhuang.github.io/blog/ruby-module/","tags":["Ruby"],"title":"Ruby 學習筆記-模組(Module)"},{"categories":["Ruby基本功"],"contents":"為什麼要有物件？ 物件 = 狀態(名詞) + 行為(動詞)\n透過物件導向程式設計，讓程式碼變得容易被理解與使用\n物件-類別與實體 類別就像是一個模型，透過這個模型可以製造出許多實體以下方程式碼為例\n定義類別： class Lily def eat puts \u0026#34; 好吃！\u0026#34; end end 產生實體： luna = Lily.new #加上new就可以產生一個個實體 luna.eat #有實體就可以使用eat這個方法 #luna是實體Lily是類別 類別的命名規定必須是常數常數必須要是大寫英文字母開頭 共同的特徵放在同一個分類(class) class Animal #把狗與貓共同會有的方法定義在上一層 def walk end def eat end end class Dog \u0026lt; Animal #會繼承Animal裡的方法 end class Cat \u0026lt; Animal #會繼承Animal裡的方法 end kitty = Cat.new #kitty這個實體屬於貓類別 kitty.eat #因為貓類別繼承Animal所以他有eat這個方法 物件初始化-initialize class Lily def initialize #特別的方法 puts \u0026#34;hello!\u0026#34; end end kitty = Lily.new # hello! #不需要呼叫方法，按執行就會出現 可使用參數 class Lily def initialize(name,age) @name = name #把 name 帶進 @name 實體變數上 @age = age end end kitty = Lily.new(\u0026#34;luna\u0026#34;,18) #luna與18會帶進上方的initialize方法參數(name,age) new 是創造一個實體，initialize 是這個實體產生後的初始化方法\n實體方法與類別方法 實體方法是作用在實體上的方法 class Lily #類別 def eat puts \u0026#34;# 好吃！\u0026#34; end end luna = Lily.new luna.eat #luna是實體,eat作用在luna上所以是實體方法 類別方法是作用在類別上的方法 在定義方法前，一定要在方法名稱前加上 self\nclass Lily def self.eat #一定要加上self puts \u0026#34; 好吃！\u0026#34; end end Lily.eat #Lily是類別,eat是作用在Lily上所以是類別方法 實體變數與類別變數 實體變數 一個＠開頭，會存活在每個獨立的實體內，在實體內可自由取用的變數\nclass Lily def initialize(name) @name = name #1.把 name 帶進 @name 實體變數上 end def say reture @name end end kitty = Lily.new(\u0026#34;luna\u0026#34;) #2.在kitty裡會有一個 @name的實體變數 kitty.say # 3.呼叫say時會回傳 @name這個變數 以上圖為例，我先用 Lily 這個類別製造一個實體名叫 kitty，再用初始化這個方法將 name 帶進@name 變成實體變數，所以我 kitty 這個實體內有個@name 的實體變數，@name 只存活在 Lily 這個類別裡，所以我無法直接呼叫 name，只能透過 say 方法把@name 回傳回來。\nattr_reader/attr_writer/attr_accessor 在 Ruby 裡沒有屬性，所以取個值變得很麻煩，也因此有了 attr_reader/attr_writer/attr_accessor 來協助，以下為例\nclass Lily attr_reader :name #只要有這個就不用在創造一個方法來回傳 attr_writer :name #只要有這個就不用創造一個方法來做 @name重新設定名字 attr_accessor :name #此方法等同與上述 2個方法 def initialize(name) @name = name end end kitty = Lily.new(\u0026#34;luna\u0026#34;) puts kitty.neme #在這裡就可以顯示了 kitty.name = \u0026#34;may\u0026#34; #在這裡可重新設定名字 類別變數 ＠＠開頭，在類別方法內可自由取用的變數\nclass Lily @@counter = 0 #類別變數 def initialize @@counter += 1 end def self.counter return @@counter end end 5.times {Lily.new} #進行5次初始化 p Lily.counter # 一樣要先創造一個self.counter的類別方法，才可以使用類別變數 # 5 開放類別 class Lily def hell0 end end class Lily def world end end kitty = Lily.new kitty.hello #可執行 kitty.world #可執行 在 Ruby 裡兩個同名的類別不會覆蓋而是融合，也因為開放的關係我可以幫現有的類別加功能，甚至內建類別也做得到。類別裡的方法則不是這樣，方法同名會覆蓋。\n類別裡方法存取控制 封裝：有些方法不想讓外部使用只想內部使用，所以有了 public/private/protected class Lily def eat #沒有明講就是public end private #不讓外部使用 def gossip end end kitty = Lily.new kitty.eat #外部可使用 kitty.gossip #因方法設定在private下，所以外部無法使用 private:不能有明確的訊息接收者，意思是可以透過別的方法來存取此方法，以下為例\nclass Lily def eat gossip end private def gossip end end kitty = Lily.new kitty.eat #private不能有明確接收者，所以存取gossip方法，先要將他放進public方法裡，才可存取 private 與 protected 差在，在 public 的方法裡 protected 可以在方法前加 self，以下為例\nclass Lily def eat self.gossip end protected def gossip end end kitty = Lily.new kitty.eat #protected不論有沒有self都存取得到，但private不可以 ","permalink":"https://LunaZhuang.github.io/blog/ruby-obj/","tags":["Ruby"],"title":"Ruby 學習筆記-物件導向程式設計(OOP)"},{"categories":["Ruby基本功"],"contents":"Block 是什麼？ 是一段不會被主動執行的程式碼，無法單獨存活\n5.times do |x| puts i end 5.times { |x| puts i } 從上述例子中的do...end以及{}都是一個 Block\nBlock 使用 在方法後使用可以用yield def say puts \u0026#34;hi\u0026#34; yield #需要用yield把控制權暫時讓給say這個Block，如果沒有的話下方的say{}不會執行 puts \u0026#34;hello\u0026#34; end say{ puts \u0026#34;welcome\u0026#34; } # hi # welcome #hello 還可以把值讓出去 def say puts \u0026#34;hi\u0026#34; yield 3 #可以在yield放值，把值讓給下方的Block puts \u0026#34;hello\u0026#34; end say{ |x| #可以接收上方，方法的值 puts x } # 3 Block 會自動回傳值 def say if yield (3) #1.讓給下方Block puts \u0026#34;yes\u0026#34; #4.接收下方Block的回傳值，來判斷是否符合 else puts \u0026#34;no\u0026#34; end end say{ |x| #2.接受上方方法 x == 3 #3.判斷讓出來的值是否有等於3 } # yes Block 不使用 return\nBlock 不是參數 如何確認方法讓出去是否有 Block\ndef say if block_given? #確認是否有block yield end end 1. say # 空白 2. say{ puts \u0026#34;hi\u0026#34; # hi } 兩種 Block 的差異 Block 物件化：被物件化後，可單獨執行 使用 Proc say = Proc.new {|x| x + 5} #包裝後的程式碼區塊 #呼叫Proc有以下的方式，結果都一樣 p say.call(3) p say[3] p say.(3) p say.===(3) #3+5=8 使用 lambda say = lambda {|x| x + 5} #包裝後的程式碼區塊 #呼叫Proc有以下的方式，結果都一樣 p say.call(3) p say[3] p say.(3) p say.===(3) #3+5=8 使用箭頭 -\u0026gt; say = -\u0026gt; (x) { x + 5} #包裝後的程式碼區塊 #呼叫Proc有以下的方式，結果都一樣 p say.call(3) p say[3] p say.(3) p say.===(3) #3+5=8 ","permalink":"https://LunaZhuang.github.io/blog/ruby-block/","tags":["Ruby"],"title":"Ruby 學習筆記-區塊(Block)"},{"categories":["JS學習"],"contents":"為什麼需要有陣列資料型態？ 因為一次只傳一個字串或數字太沒有效率，弄個集合包裝把所有資料放到裡面在一次傳過去。\n在 JavaScript 可以放不同種類的資料型態，但其他語言程式不一定。\n建立陣列使用陣列 const list = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;, 1, 2, 3]; console.log(list[0]); //索引值都是從0開始計算，例如：要拿到資料字串\u0026#34;a\u0026#34;。 console.log(list.length) //6，陣列裡有６個元素 list[1] = \u0026#34;x\u0026#34;; //把x值指定給list[1]，js會依據索引值把x送進去並修改成[ \u0026#39;a\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;c\u0026#39;, 1, 2, 3 ] const list = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;, 1, 2, 3, \u0026#34;d\u0026#34;]; console.log(list[list.length - 1]); //無論加多少資料進去，我都可以拿到最後一筆資料 何謂二維陣列、三維陣列 在陣列中又包陣列\nlet data = [ [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;], [1,2,3,4], [\u0026#34;f\u0026#34;,\u0026#34;h\u0026#34;] ] console.log(data[1][1]); //2 陣列中可使用的方法 以下只會說明一些，詳請參考MDN 上的說明\n新增、刪除陣列方法 從陣列後方加上新的元素，使用方法push() 從陣列前方加上新的元素，使用方法unshift() 從陣列後方刪除元素，使用方法pop() 從陣列前方刪除元素，使用方法shift() 新增: const data = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;]; data.push(1); console.log(data); //[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, 1 ] data.unshift(2) console.log(data); //[2, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, 1 ] 刪除 const data = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;]; data.pop(); console.log(data); //[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39; ] data.shift(); console.log(data); //[ \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39; ] map()方法對原陣列中每個元素做動作，會回傳一個新陣列 const list = [ 1, 2, 3, 4, 5]; let result = list.map(function(x){ return x * 2 ; }); console.log(result); //[ 2, 4, 6, 8, 10 ] forEach()方法對原陣列中每個元素做動作 與 map()差在 forEach()不會回傳新的陣列\nconst list = [1,2,3,4,5]; list.forEach(function(el){ console.log(el*2); }); //2 //4 //6 //8 //10 filter()過濾器只要條件滿足就留下該元素 const list = [1, 2, 3, 4, 5, 6, 7]; const result = list.filter(function(x){ return x % 2 == 1 ; }); console.log(result); //[ 1, 3, 5, 7 ] splice()該方法通過刪除或替換現有元素或在適當位置添加新元素來更改數組的內容。 const data = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;]; data.splice(2,3) //從索引值2開始,刪掉3個元素 console.log(data); //[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;] const data = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;]; data.splice(2,2,\u0026#34;x\u0026#34;); console.log(data); //[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;e\u0026#39; ] const data = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;]; data.splice(3,0,\u0026#34;x\u0026#34;); //從索引值3開始，刪除0個，並往前加入一個x console.log(data); //[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39; ] function myPush(arr, elm) { arr.splice(arr.length,0,elm) return arr } const data = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] const result = myPush(data, \u0026#34;x\u0026#34;) console.log(result) // [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;x\u0026#34;] reduce()將一個累加器及陣列中每項元素（由左至右）傳入回呼函式，將陣列化為單一值 const list = [1, 2, 3, 4, 5, 6, 7]; const total = list.reduce(function(sum,num){ return sum + num; },0); //0是初始值 console.log(total); //28 ------------------------------ const list = [1, 4, 3, 9, 2, 6, 7, 8]; const total = list.reduce(function (acc, cv) { if (cv \u0026gt; acc) { return cv; } else { return acc; } }) console.log(total); //比大小最後cv會是9 ","permalink":"https://LunaZhuang.github.io/blog/js-array/","tags":["JavaScript"],"title":"JavaScript-陣列(Array)"},{"categories":["Ruby基本功"],"contents":"為什麼需要方法？ 可以重複使用。 可以讓程式碼變得更容易理解。 如何定義及使用 定義： def method_name(param1, param2) #參數一個或2個都可以，但有多少參數就要有多少引數 #內容 end 使用： method_name(param) #把方法呼叫出來 可以預設參數: def hello (someone = \u0026#34;luna\u0026#34;) puts \u0026#34;hi,#{someone} welcome my blog\u0026#34; end hello() #如果沒有放入引數，他會出現hi,luna welcome my blog #如果有放入引數hello(\u0026#34;lily\u0026#34;)，會出現hi,lily welcome my blog 所謂的回傳值 回傳 = 交回控制權\n呼叫方法與回傳值： def calculate(num) return 2*num end puts calculate(3) 以上面方法為例，當執行時會有的步驟\n會先呼叫 calculate 方法，並傳入 3 作為引數 執行 calculate 方法 return 交還控制權，並同時回傳計算結果 把計算結果交給呼叫方法的地方，用 puts 方法印出來 return 與 puts、p 差在哪？ 當有 return 時，在方法外面呼叫並用 puts 方法印出時會有回傳值，如果沒有 return 在方法外面用 puts 方法印出時會出現 nil，如要有內容印出，須在方法裡使用 puts 方法，才能在沒有回傳值的時候呼叫方法名字並印出內容，唯一例外的是 p 方法他也是印出的方法但他同時也有回傳值的功能，不過不建議用 p 取代 return，例\ndef calculate(num) return 2 x num #有return才有回傳值 end puts calculate(3) #執行時用p方法呼叫並印出內容 def calculate(num) puts 2 x num #沒有return，他不會回傳東西到呼叫那裡，他只是在方法裡把東西印出來 end p calculate(3) #先呼叫才執行，這裡會出現nil def calculate(num) 2 x num #沒有return也沒有puts end puts calculate(3) #會出現nil，因為沒有回傳值 問號？與驚嘆號！ 可以放在方法命名裡，但只能放在最後面 問號通常會回傳真假值 驚嘆號通常表示要注意 Ruby 官網上的說明 ","permalink":"https://LunaZhuang.github.io/blog/ruby-method/","tags":["Ruby"],"title":"Ruby 學習筆記-方法(method)"},{"categories":["Ruby基本功"],"contents":"為什麼需要有陣列資料型態？ 因為一次只傳一個字串或數字太沒有效率，弄個集合包裝把所有資料放到裡面在一次傳過去。\n建立陣列 #使用Array類別 a = Array.new #使用中括號 b = [] #一樣可以建立陣列，但要小心裡面的東西會變成字串 list = %w(ruby php python) 使用陣列 陣列索引值都是從 0 開始計算，從後面就是由-1 開始。 list = [\u0026#34;ruby\u0026#34;,\u0026#34;php\u0026#34;,\u0026#34;python\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;java\u0026#34;,\u0026#34;JavaScript\u0026#34;] puts list[0] #印出 ruby puts list[1] #印出 php puts list[-1] #印出 JavaScript puts list[-2] #印出 java #ruby方法 puts list.first #印出 ruby puts list.last #印出 JavaScript puts list.length #印出 6 ，代表陣列裡有6個元素 list \u0026lt;\u0026lt; \u0026#34;React\u0026#34; #在最後面加一個元素 puts list.length #印出 7 list.push(\u0026#34;vue.js\u0026#34;) #也可以用此種方式在陣列後方加元素 puts list.length #印出８ map:對集合裡的每個元素進行運算，並收集成一個新的集合。\n同意詞：collect\nlist = [1, 2, 3, 4, 5] p list.map { | x | x × 2 } #會把裡面每個元素丟進x裡，再乘於2得到新的集合[2, 4 , 6, 8, 10 ] p list.collect { | x | x × 2 } #得出的結果與上面一樣 p(1..10).map { | x | x × 2 } #(1..10)數字1到10依順序丟進x裡，得出[2, 4, 6 , 8, 10, 12, 14, 16, 18, 20] select:從集合裡挑選符合條件的元素，並收集成一個新的集合。\n同意詞：filter\n反意詞：reject\np (1..10).select { | x | x \u0026lt; 5} #從數字1到10裡挑選出符合小於 5 的數字，得出[1, 2, 3, 4] p (1..10).reject { | x | x \u0026lt; 5} #從數字1到10裡挑選出不符合小於 5 的數字，得出[5, 6, 7, 8, 9, 10] reduce:對集合裡的每個元素進行運算，並將所有的運算結果歸納成一個單一結果。 同義詞：inject\np (1..10).reduce { |sum, x| sum + x} #1到10的數字會依序丟進 x 裡，再由 sum 負責依序將所有 x 值累加起來，得到 55 範圍 puts (1..10).to_a #印出 1~10 ，to_a轉成陣列 puts (1...10).to_a #印出 1~9 不只可以用在數字上，也可以用在文字上(\u0026quot;a\u0026quot;..\u0026quot;z\u0026quot;)\n與 for 迴圈結合\nfor i in 1..10 puts i end 與 case..when..結合 age = 10 case age when 0..3 puts \u0026#34;嬰兒\u0026#34; when 4..10 puts \u0026#34;兒童\u0026#34; when 11..17 puts \u0026#34;青少年\u0026#34; else puts \u0026#34;成年\u0026#34; end ","permalink":"https://LunaZhuang.github.io/blog/ruby-arrayrange/","tags":["Ruby"],"title":"Ruby 學習筆記-陣列\u0026範圍（Array＆Range）"},{"categories":["Ruby基本功"],"contents":"為什麼要設迴圈？ 因為重複的代碼可以不用一直寫，只要寫好一個迴圈就可以設定他跑十次，最後的結果是一樣的，但可以少寫很多 code。\n迴圈種類 for 迴圈 while 迴圈 loop 迴圈 method 迴圈-Ruby 特有 迭代式迴圈 迴圈與迭代有什麼不同？ 迴圈：不斷的依據指定的條件重複執行某些指令。 迭代：通常會有個對象，針對某個集合的每個元素做某些事。 迴圈寫法 for 迴圈 names = [\u0026#34;eddie\u0026#34;,\u0026#34;joanne\u0026#34;,\u0026#34;john\u0026#34;,\u0026#34;sherly\u0026#34;] for name in names puts name end #設一個變數name一圈一個把names裡面的東西印出來。 for i in 1..10 puts i end while 迴圈(小心變成無窮迴圈，條件設定要設好) x = 0 while x \u0026lt; 10 puts x x += 1 #改變條件 end #一開始x設為0，當x小於10時會印出來0，在印出來後改變條件，變成x=1，一直重複直到x=10。 邪惡分身 until，while not = until\nloop 迴圈(break 一定要設好) i = 0 loop do puts i i += 1 break if i \u0026gt; 10 #break 結束這回合 end #一開始設i為0，先印出來再改變變數,後設條件。 #跟while差在一個先設條件符合條件在執行，loop是你先執行，條件不符在跳出。 do..end或是{}這個叫做 Block(程式碼區塊)\nmethod 式迴圈 5.times do puts \u0026#34;hello,ruby\u0026#34; end #意思是我要印5次hello,ruby。 1.upto(10) do |i| puts \u0026#34;hello,ruby #{i}\u0026#34; end #把數字1到10放進絕對值裡，再帶進${}裡，每次印出hello,ruby時後面的數字會從1到10跟隨印出結束。 10.downto(1) do |i| puts \u0026#34;hello,ruby #{i}\u0026#34; end #把數字10到1放進絕對值裡，再帶進${}裡，每次印出hello,ruby時後面的數字會從10到1跟隨印出結束。 迭代式回圈 names = [\u0026#34;eddie\u0026#34;,\u0026#34;joanne\u0026#34;,\u0026#34;john\u0026#34;,\u0026#34;sherly\u0026#34;] names.each do |name| puts name end #把names裡的元素丟出來給name這個變數，並把它印出來。 names = [\u0026#34;eddie\u0026#34;,\u0026#34;joanne\u0026#34;,\u0026#34;john\u0026#34;,\u0026#34;sherly\u0026#34;] name.each.with_index do |name,x| puts \u0026#34;#{x} #{name}\u0026#34; end #把names裡的每個元素丟出來給name這個變數，再把每個元素的索引值丟給x這個變數，一起印出來。 ","permalink":"https://LunaZhuang.github.io/blog/ruby-loop/","tags":["Ruby"],"title":"Ruby 學習筆記-迴圈與迭代（Loop\u0026Iteration）"},{"categories":["JS學習"],"contents":"為什麼程式語言都需要變數？ 變數只是個名字，只是為了要識別，讓你程式語言在計算的時候，有個放計算資料內容的容器，當你在執行的時候就可以，依照你給他的容器名稱，把他叫出來使用，變數本身沒意義。\n指定又是什麼？ 在程式語言中=(x 等號)而是指定，由右側的值指定給左側的變數名稱。==則是比較兩邊的值。 但在 JavaScript 中==雖然也是比較的意思，不過 JavaScript 會有自動轉型的問題，為了不要讓你的程式碼出現奇怪的內容，建議使用更為嚴謹的===。\n變數的命名 可以使用英文字母或數字，但第一個字不可以是數字。 不能使用保留字 注意英文大小寫有差 保留字 break case catch class const continue debugger default delete do else export extends finally for function if import in instanceof new return super switch this throw try typeof var void while with yield 變數命名需清楚與有意義。 變數名稱慣例 CamelCase(JavaScript) camelCase snake_case(Ruby) 變數有沒有宣告有差嗎？ 有宣告叫變數，沒宣告叫指定。 變數 未定義(undefined) VS 沒有定義(not define) 變數提昇(variable hoisting)與暫時性死區 JavaScript 在瀏覽器執行時會有兩個階段，一個叫建立期(creation phases)另一個是執行期(execution phases)。官網上的說明 建立期 JavaScript 會先將你宣告的變數儲存，再給他一個初始化的值 undefined。\n執行期再按照程式碼逐行執行代碼，將值分配給變量，並執行函數調用。\nES6 後為了要修正 JavaScript 這個問題新增了 let 變數與 const 常數，在 let 與 const 上第一張圖執行結果與 var 變數是相同的，差別在與第二張圖，let 與 const 多了一個叫 TDZ(暫時死區)，執行後的結果會有所差異，請看下圖。 範圍鏈(Scope chain) 從上圖可知在 function 裡的 var 變數不會影響到外部程式，可在 if 身上會影響到外面的 console.log(a)，代表 var 是 function scope。\n同理從上圖可知 function 裡的 let 變數不會影響到外部程式，在 if 身上也不會影響到外面的 console.log(a)，代表 let 是 block scope{}。\nlet,const,var 怎麼選擇？ 能用 const 就用 const，不能用 const 就改用 let var 也可以用，只是它的範圍(Scope)比較大一些 千萬不要沒宣告就拿來用，那會造成全域物件的污染 var let/const Scope function scope block scope{} 重複宣告 可 不可 變數內容重複指定 可 可/不可 可能會造成全域屬性 會 不會 變數提昇 有 有(被 TDZ 罩住) JavaScript 2 種型別 原始型別 數字 (Number) 字串 (String) 真假值 (Boolean) 空值 (Null) 未定義 (Undefined) 符號 (Symbol) 物件型別 陣列(Array) 函數(Function) 物件(Object) 對 JavaScript 來說，false,0,\u0026quot;\u0026quot;,undefind,null 都是假的，其餘為真。 ","permalink":"https://LunaZhuang.github.io/blog/js-variableconstant/","tags":["JavaScript"],"title":"JavaScript-變數與常數"},{"categories":["HTML"],"contents":"關於網頁的組成 在網頁開發中最基本有三大元素：HTML、CSS、JavaScript。HTML 就是先將資料結構化，並給於資料標記分類。寫網頁中最主要的就是網頁內容，網頁內容就是我們要呈現的資料，網頁製作是將這些資料使用正確的 HTML 語法將資料標記起來。\n在 HTML 上標記標籤的方式是使用 \u0026lt;起始標籤\u0026gt;內容\u0026lt;/結束標籤\u0026gt; 的方式標記。 \u0026lt;\u0026gt; 這是標籤，裡面會有 \u0026lt;元素\u0026gt;，元素是告訴瀏覽器我這個標籤裡是什麼種類的資料，像是下圖我用 \u0026lt; p \u0026gt; 告訴他這是一段文字內容，網頁上就會呈現出來。\n在元素裡還可以放\u0026lt; p 屬性\u0026gt;\n屬性的組成包含： 在元素名稱和屬性之間有一個空格（如果有多個屬性，屬性之間也需要有空格）。 屬性名稱後面接著等於符號「=」。 屬性包在起始標籤裡面，如上圖所示。 網頁是由眾多標籤元素合在一起像是下圖(MDN 標籤元素大全) 寫網頁要清楚你的這個網頁的重點是什麼，才知道你的網頁要用什麼標籤撰寫。HTML 語意最重要，視覺外觀不是重點。 ","permalink":"https://LunaZhuang.github.io/blog/html/","tags":["HTML"],"title":"HTML(超文本標記語言) "},{"categories":["Ruby基本功"],"contents":"1.等號判斷 a =10 b = \u0026#34;10\u0026#34; p a == b #false p a === b #false 一個等號是指代的意思，二個等號與三個等號都是比較的意思。\n在 JS 上a == b，兩個等號會自動轉型，結果會回傳 true。\n2.如果判斷式 if time = \u0026#34;早上\u0026#34; if time == \u0026#34;早上\u0026#34; puts \u0026#34;好想賴床\u0026#34; end #條件成立的話 if 倒裝句 puts \u0026#34;好想賴床\u0026#34; if time == \u0026#34;早上\u0026#34; #與上面結果相同 unless = if not / if = unless not time = \u0026#34;晚上\u0026#34; if not time == \u0026#34;早上\u0026#34; puts \u0026#34;熬夜追劇！\u0026#34; end #與下列程式相等 unless time == \u0026#34;早上\u0026#34; puts \u0026#34;熬夜追劇！\u0026#34; end unless 倒裝句 puts \u0026#34;熬夜追劇！\u0026#34; unless time == \u0026#34;早上\u0026#34; 不要為了 unless 而 unless，先看自己看不看得懂，以自己能懂為最主要，可以寫 if not 。 if..else.. 二分法 time = \u0026#34;早上\u0026#34; if time == \u0026#34;早上\u0026#34; puts \u0026#34;好想賴床\u0026#34; else puts \u0026#34;熬夜追劇！\u0026#34; end 三元運算子 age = 19 if age \u0026gt;= 19 status = \u0026#34;已成年\u0026#34; else status = \u0026#34;未成年\u0026#34; end ##與下列程式相等 status = (age\u0026gt;=18) ? \u0026#34;已成年\u0026#34;:\u0026#34;未成年\u0026#34; 3.更多條件 if..elsif..else.. time = \u0026#34;早上\u0026#34; if time == \u0026#34;早上\u0026#34; puts \u0026#34;好想賴床\u0026#34; elsif time == \u0026#34;晚上\u0026#34; puts \u0026#34;熬夜追劇！\u0026#34; else puts \u0026#34;睡午覺\u0026#34; end case..when.. time = \u0026#34;早上\u0026#34; case time when \u0026#34;早上\u0026#34; puts \u0026#34;好想賴床\u0026#34; when \u0026#34;晚上\u0026#34; puts \u0026#34;熬夜追劇！\u0026#34; else puts \u0026#34;睡午覺\u0026#34; end ","permalink":"https://LunaZhuang.github.io/blog/ruby-logic/","tags":["Ruby"],"title":"Ruby 學習筆記-邏輯判斷"},{"categories":["Ruby基本功"],"contents":"1.字串的串接 2.字串引號種類 名稱 引號 範例 雙引號 \u0026quot; \u0026quot; puts \u0026ldquo;Hi\u0026rdquo; 單引號 \u0026rsquo; ' puts \u0026lsquo;Hi\u0026rsquo; 跳脫字元 \u0026rsquo; \\ ' puts \u0026lsquo;Hi, I'm Luna\u0026rsquo; 效果等於雙引號 %Q puts %Q(Hi) 效果等於單引號 %q puts %q(Hi) 3.數字-整數與浮點數 puts 3.55.round # 轉成整數，四捨五入 puts 3.74.floor # 轉成整數，無條件捨去 puts 3.14.ceil # 轉成整數，無條件進位 puts 3.14.to_i # 轉成整數，無條件捨去 4.除法 puts 10/3 # 整數除以整數得到3 puts 10.0/3 # 3.33333333 puts 10/3.0 # 3.33333333 puts 10.0/3.0 # 3.33333333 ","permalink":"https://LunaZhuang.github.io/blog/ruby-stringandnumber/","tags":["Ruby"],"title":"Ruby 學習筆記-字串＆數字（String\u0026Number）"},{"categories":["Ruby基本功"],"contents":"1.Ruby 變數種類 2.變數指定 a = a + 2 一個等號是指定 也可以寫成這樣 3.變數多重指定 a.可以利用 Ruby 變數多重指定特性寫成這樣 x,y,z = 1,2,3\nb.如果等號的右邊是陣列也可以自動拆解出來 x,y,z = [1,2,3]\n4.變數的命名慣例 Ruby 世界裡有不成文規定 是使用小寫英文字母以及底線來組合變數名稱，例如像是 my_shopping_cart，稱之蛇形命名法（Snake Case）。 5.常數命名 常數必須要是大寫英文字母開頭 Luna = 1 在寫程式時需要給變數一個好名字 具有清楚與有意義(給 x,y,z 不能使人清楚這段程式碼在寫什麼) 變數與常數就像標籤本身沒有型態 可以把它想像成是「一張有寫著名字的標籤，貼在某個東西上面」，被貼的那個東西有形態，但標籤本身沒有。 ","permalink":"https://LunaZhuang.github.io/blog/ruby-variable/","tags":["Ruby"],"title":"Ruby 學習筆記-變數＆常數（Variable）"},{"categories":["Ruby基本功"],"contents":"Ruby 裡的符號＝有名字的物件（值） 與數字１,2,3 一樣都是有固定的值並不能改變\n１就是１，２就是２\n符號 ：name ，就是：name 不是變數不可以改變他的值\n字串 name=\u0026quot;amber\u0026quot;，name 變數指向一個字串，並可以改變字串內容\n總結：字串與符號的差別 １．字串的內容可以變，但符號不行\n２．字串的效能稍微差一點點\n","permalink":"https://LunaZhuang.github.io/blog/ruby-symbol/","tags":["Ruby"],"title":"Ruby 學習筆記-符號（Symbol）"}]