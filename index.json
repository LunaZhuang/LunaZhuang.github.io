[{"categories":["Ruby基本功"],"contents":"為什麼要用模組 class 繼承 class 的方法不就好了？為什麼還要有模組？ 因為你只是想要類別裡的其中一個方法，但為了這方法就要繼承這個類別裡的所有方法，這有點過本末倒置。\n定義與使用模組 模組的命名規定必須是常數常數必須要是大寫英文字母開頭\ninclude:作用在實體方法\nmodule Flyable #定義 def fly puts \u0026#34;fly\u0026#34; end end class Cat include Flyable #引進 end kitty = Cat.new kitty.fly #使用 #因為Cat這個類別有引進Flyable這個模組，所以也可以使用fly方法 extend:作用在類別方法\nmodule Flyable #定義 def fly puts \u0026#34;fly\u0026#34; end end class Cat extend Flyable #在類別裡擴充 end Cat.fly #類別方法 模組與類別的差異 模組沒有繼承的功能，所以不能 module Flyable \u0026lt; SomeModule 模組不能實體化，所以不能 kitty = Flyable.new 在 Ruby 裡冒號位置的意思 冒號在左 has_many :name 是符號 冒號在右 {name: \u0026quot;lily\u0026quot;, age: 18} 是 hash 的 key 冒號在中間,中間有留白 {direction: :up, power: 53} 前面是 key 後面是符號 冒號在中間,中間沒有留白 class User \u0026lt; ActiveRecord::Base User 是繼承 ActiveRecord 模組裡有個叫 Base 的類別 ","permalink":"https://LunaZhuang.github.io/blog/ruby-module/","tags":["Ruby"],"title":"Ruby 學習筆記-模組(Module)"},{"categories":["Ruby基本功"],"contents":"為什麼要有物件？ 物件 = 狀態(名詞) + 行為(動詞)\n透過物件導向程式設計，讓程式碼變得容易被理解與使用\n物件-類別與實體 類別就像是一個模型，透過這個模型可以製造出許多實體以下方程式碼為例\n定義類別： class Lily def eat puts \u0026#34; 好吃！\u0026#34; end end 產生實體： luna = Lily.new #加上new就可以產生一個個實體 luna.eat #有實體就可以使用eat這個方法 #luna是實體Lily是類別 類別的命名規定必須是常數常數必須要是大寫英文字母開頭 共同的特徵放在同一個分類(class) class Animal #把狗與貓共同會有的方法定義在上一層 def walk end def eat end end class Dog \u0026lt; Animal #會繼承Animal裡的方法 end class Cat \u0026lt; Animal #會繼承Animal裡的方法 end kitty = Cat.new #kitty這個實體屬於貓類別 kitty.eat #因為貓類別繼承Animal所以他有eat這個方法 物件初始化-initialize class Lily def initialize #特別的方法 puts \u0026#34;hello!\u0026#34; end end kitty = Lily.new # hello! #不需要呼叫方法，按執行就會出現 可使用參數 class Lily def initialize(name,age) @name = name #把 name 帶進 @name 實體變數上 @age = age end end kitty = Lily.new(\u0026#34;luna\u0026#34;,18) #luna與18會帶進上方的initialize方法參數(name,age) new 是創造一個實體，initialize 是這個實體產生後的初始化方法\n實體方法與類別方法 實體方法是作用在實體上的方法 class Lily #類別 def eat puts \u0026#34;# 好吃！\u0026#34; end end luna = Lily.new luna.eat #luna是實體,eat作用在luna上所以是實體方法 類別方法是作用在類別上的方法 在定義方法前，一定要在方法名稱前加上 self\nclass Lily def self.eat #一定要加上self puts \u0026#34; 好吃！\u0026#34; end end Lily.eat #Lily是類別,eat是作用在Lily上所以是類別方法 實體變數與類別變數 實體變數 一個＠開頭，會存活在每個獨立的實體內，在實體內可自由取用的變數\nclass Lily def initialize(name) @name = name #1.把 name 帶進 @name 實體變數上 end def say reture @name end end kitty = Lily.new(\u0026#34;luna\u0026#34;) #2.在kitty裡會有一個 @name的實體變數 kitty.say # 3.呼叫say時會回傳 @name這個變數 以上圖為例，我先用 Lily 這個類別製造一個實體名叫 kitty，再用初始化這個方法將 name 帶進@name 變成實體變數，所以我 kitty 這個實體內有個@name 的實體變數，@name 只存活在 Lily 這個類別裡，所以我無法直接呼叫 name，只能透過 say 方法把@name 回傳回來。\nattr_reader/attr_writer/attr_accessor 在 Ruby 裡沒有屬性，所以取個值變得很麻煩，也因此有了 attr_reader/attr_writer/attr_accessor 來協助，以下為例\nclass Lily attr_reader :name #只要有這個就不用在創造一個方法來回傳 attr_writer :name #只要有這個就不用創造一個方法來做 @name重新設定名字 attr_accessor :name #此方法等同與上述 2個方法 def initialize(name) @name = name end end kitty = Lily.new(\u0026#34;luna\u0026#34;) puts kitty.neme #在這裡就可以顯示了 kitty.name = \u0026#34;may\u0026#34; #在這裡可重新設定名字 類別變數 ＠＠開頭，在類別方法內可自由取用的變數\nclass Lily @@counter = 0 #類別變數 def initialize @@counter += 1 end def self.counter return @@counter end end 5.times {Lily.new} #進行5次初始化 p Lily.counter # 一樣要先創造一個self.counter的類別方法，才可以使用類別變數 # 5 開放類別 class Lily def hell0 end end class Lily def world end end kitty = Lily.new kitty.hello #可執行 kitty.world #可執行 在 Ruby 裡兩個同名的類別不會覆蓋而是融合，也因為開放的關係我可以幫現有的類別加功能，甚至內建類別也做得到。類別裡的方法則不是這樣，方法同名會覆蓋。\n類別裡方法存取控制 封裝：有些方法不想讓外部使用只想內部使用，所以有了 public/private/protected class Lily def eat #沒有明講就是public end private #不讓外部使用 def gossip end end kitty = Lily.new kitty.eat #外部可使用 kitty.gossip #因方法設定在private下，所以外部無法使用 private:不能有明確的訊息接收者，意思是可以透過別的方法來存取此方法，以下為例\nclass Lily def eat gossip end private def gossip end end kitty = Lily.new kitty.eat #private不能有明確接收者，所以存取gossip方法，先要將他放進public方法裡，才可存取 private 與 protected 差在，在 public 的方法裡 protected 可以在方法前加 self，以下為例\nclass Lily def eat self.gossip end protected def gossip end end kitty = Lily.new kitty.eat #protected不論有沒有self都存取得到，但private不可以 ","permalink":"https://LunaZhuang.github.io/blog/ruby-obj/","tags":["Ruby"],"title":"Ruby 學習筆記-物件導向程式設計(OOP)"},{"categories":["Ruby基本功"],"contents":"Block 是什麼？ 是一段不會被主動執行的程式碼，無法單獨存活\n5.times do |x| puts i end 5.times { |x| puts i } 從上述例子中的do...end以及{}都是一個 Block\nBlock 使用 在方法後使用可以用yield def say puts \u0026#34;hi\u0026#34; yield #需要用yield把控制權暫時讓給say這個Block，如果沒有的話下方的say{}不會執行 puts \u0026#34;hello\u0026#34; end say{ puts \u0026#34;welcome\u0026#34; } # hi # welcome #hello 還可以把值讓出去 def say puts \u0026#34;hi\u0026#34; yield 3 #可以在yield放值，把值讓給下方的Block puts \u0026#34;hello\u0026#34; end say{ |x| #可以接收上方，方法的值 puts x } # 3 Block 會自動回傳值 def say if yield (3) #1.讓給下方Block puts \u0026#34;yes\u0026#34; #4.接收下方Block的回傳值，來判斷是否符合 else puts \u0026#34;no\u0026#34; end end say{ |x| #2.接受上方方法 x == 3 #3.判斷讓出來的值是否有等於3 } # yes Block 不使用 return\nBlock 不是參數 如何確認方法讓出去是否有 Block\ndef say if block_given? #確認是否有block yield end end 1. say # 空白 2. say{ puts \u0026#34;hi\u0026#34; # hi } 兩種 Block 的差異 Block 物件化：被物件化後，可單獨執行 使用 Proc say = Proc.new {|x| x + 5} #包裝後的程式碼區塊 #呼叫Proc有以下的方式，結果都一樣 p say.call(3) p say[3] p say.(3) p say.===(3) #3+5=8 使用 lambda say = lambda {|x| x + 5} #包裝後的程式碼區塊 #呼叫Proc有以下的方式，結果都一樣 p say.call(3) p say[3] p say.(3) p say.===(3) #3+5=8 使用箭頭 -\u0026gt; say = -\u0026gt; (x) { x + 5} #包裝後的程式碼區塊 #呼叫Proc有以下的方式，結果都一樣 p say.call(3) p say[3] p say.(3) p say.===(3) #3+5=8 ","permalink":"https://LunaZhuang.github.io/blog/ruby-block/","tags":["Ruby"],"title":"Ruby 學習筆記-區塊(Block)"},{"categories":["JS入門"],"contents":"為什麼需要有陣列資料型態？ 因為一次只傳一個字串或數字太沒有效率，弄個集合包裝把所有資料放到裡面在一次傳過去。\n在 JavaScript 可以放不同種類的資料型態，但其他語言程式不一定。\n建立陣列使用陣列 const list = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;, 1, 2, 3]; console.log(list[0]); //索引值都是從0開始計算，例如：要拿到資料字串\u0026#34;a\u0026#34;。 console.log(list.length) //6，陣列裡有６個元素 list[1] = \u0026#34;x\u0026#34;; //把x值指定給list[1]，js會依據索引值把x送進去並修改成[ \u0026#39;a\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;c\u0026#39;, 1, 2, 3 ] const list = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;, 1, 2, 3, \u0026#34;d\u0026#34;]; console.log(list[list.length - 1]); //無論加多少資料進去，我都可以拿到最後一筆資料 何謂二維陣列、三維陣列 在陣列中又包陣列\nlet data = [ [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;], [1,2,3,4], [\u0026#34;f\u0026#34;,\u0026#34;h\u0026#34;] ] console.log(data[1][1]); //2 陣列中可使用的方法 以下只會說明一些，詳請參考MDN 上的說明\n新增、刪除陣列方法 從陣列後方加上新的元素，使用方法push() 從陣列前方加上新的元素，使用方法unshift() 從陣列後方刪除元素，使用方法pop() 從陣列前方刪除元素，使用方法shift() 新增: const data = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;]; data.push(1); console.log(data); //[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, 1 ] data.unshift(2) console.log(data); //[2, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, 1 ] 刪除 const data = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;]; data.pop(); console.log(data); //[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39; ] data.shift(); console.log(data); //[ \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39; ] map()方法對原陣列中每個元素做動作，會回傳一個新陣列 const list = [ 1, 2, 3, 4, 5]; let result = list.map(function(x){ return x * 2 ; }); console.log(result); //[ 2, 4, 6, 8, 10 ] forEach()方法對原陣列中每個元素做動作 與 map()差在 forEach()不會回傳新的陣列\nconst list = [1,2,3,4,5]; list.forEach(function(el){ console.log(el*2); }); //2 //4 //6 //8 //10 filter()過濾器只要條件滿足就留下該元素 const list = [1, 2, 3, 4, 5, 6, 7]; const result = list.filter(function(x){ return x % 2 == 1 ; }); console.log(result); //[ 1, 3, 5, 7 ] splice()該方法通過刪除或替換現有元素或在適當位置添加新元素來更改數組的內容。 const data = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;]; data.splice(2,3) //從索引值2開始,刪掉3個元素 console.log(data); //[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;] const data = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;]; data.splice(2,2,\u0026#34;x\u0026#34;); console.log(data); //[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;e\u0026#39; ] const data = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;]; data.splice(3,0,\u0026#34;x\u0026#34;); //從索引值3開始，刪除0個，並往前加入一個x console.log(data); //[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39; ] function myPush(arr, elm) { arr.splice(arr.length,0,elm) return arr } const data = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] const result = myPush(data, \u0026#34;x\u0026#34;) console.log(result) // [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;x\u0026#34;] reduce()將一個累加器及陣列中每項元素（由左至右）傳入回呼函式，將陣列化為單一值 const list = [1, 2, 3, 4, 5, 6, 7]; const total = list.reduce(function(sum,num){ return sum + num; },0); //0是初始值 console.log(total); //28 ------------------------------ const list = [1, 4, 3, 9, 2, 6, 7, 8]; const total = list.reduce(function (acc, cv) { if (cv \u0026gt; acc) { return cv; } else { return acc; } }) console.log(total); //比大小最後cv會是9 ","permalink":"https://LunaZhuang.github.io/blog/js-array/","tags":["JavaScript"],"title":"JavaScript-陣列(Array)"},{"categories":["Ruby基本功"],"contents":"為什麼需要方法？ 可以重複使用。 可以讓程式碼變得更容易理解。 如何定義及使用 定義： def method_name(param1, param2) #參數一個或2個都可以，但有多少參數就要有多少引數 #內容 end 使用： method_name(param) #把方法呼叫出來 可以預設參數: def hello (someone = \u0026#34;luna\u0026#34;) puts \u0026#34;hi,#{someone} welcome my blog\u0026#34; end hello() #如果沒有放入引數，他會出現hi,luna welcome my blog #如果有放入引數hello(\u0026#34;lily\u0026#34;)，會出現hi,lily welcome my blog 所謂的回傳值 回傳 = 交回控制權\n呼叫方法與回傳值： def calculate(num) return 2*num end puts calculate(3) 以上面方法為例，當執行時會有的步驟\n會先呼叫 calculate 方法，並傳入 3 作為引數 執行 calculate 方法 return 交還控制權，並同時回傳計算結果 把計算結果交給呼叫方法的地方，用 puts 方法印出來 return 與 puts、p 差在哪？ 當有 return 時，在方法外面呼叫並用 puts 方法印出時會有回傳值，如果沒有 return 在方法外面用 puts 方法印出時會出現 nil，如要有內容印出，須在方法裡使用 puts 方法，才能在沒有回傳值的時候呼叫方法名字並印出內容，唯一例外的是 p 方法他也是印出的方法但他同時也有回傳值的功能，不過不建議用 p 取代 return，例\ndef calculate(num) return 2 x num #有return才有回傳值 end puts calculate(3) #執行時用p方法呼叫並印出內容 def calculate(num) puts 2 x num #沒有return，他不會回傳東西到呼叫那裡，他只是在方法裡把東西印出來 end p calculate(3) #先呼叫才執行，這裡會出現nil def calculate(num) 2 x num #沒有return也沒有puts end puts calculate(3) #會出現nil，因為沒有回傳值 問號？與驚嘆號！ 可以放在方法命名裡，但只能放在最後面 問號通常會回傳真假值 驚嘆號通常表示要注意 Ruby 官網上的說明 ","permalink":"https://LunaZhuang.github.io/blog/ruby-method/","tags":["Ruby"],"title":"Ruby 學習筆記-方法(method)"},{"categories":["Ruby基本功"],"contents":"為什麼需要有陣列資料型態？ 因為一次只傳一個字串或數字太沒有效率，弄個集合包裝把所有資料放到裡面在一次傳過去。\n建立陣列 #使用Array類別 a = Array.new #使用中括號 b = [] #一樣可以建立陣列，但要小心裡面的東西會變成字串 list = %w(ruby php python) 使用陣列 陣列索引值都是從 0 開始計算，從後面就是由-1 開始。 list = [\u0026#34;ruby\u0026#34;,\u0026#34;php\u0026#34;,\u0026#34;python\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;java\u0026#34;,\u0026#34;JavaScript\u0026#34;] puts list[0] #印出 ruby puts list[1] #印出 php puts list[-1] #印出 JavaScript puts list[-2] #印出 java #ruby方法 puts list.first #印出 ruby puts list.last #印出 JavaScript puts list.length #印出 6 ，代表陣列裡有6個元素 list \u0026lt;\u0026lt; \u0026#34;React\u0026#34; #在最後面加一個元素 puts list.length #印出 7 list.push(\u0026#34;vue.js\u0026#34;) #也可以用此種方式在陣列後方加元素 puts list.length #印出８ map:對集合裡的每個元素進行運算，並收集成一個新的集合。\n同意詞：collect\nlist = [1, 2, 3, 4, 5] p list.map { | x | x × 2 } #會把裡面每個元素丟進x裡，再乘於2得到新的集合[2, 4 , 6, 8, 10 ] p list.collect { | x | x × 2 } #得出的結果與上面一樣 p(1..10).map { | x | x × 2 } #(1..10)數字1到10依順序丟進x裡，得出[2, 4, 6 , 8, 10, 12, 14, 16, 18, 20] select:從集合裡挑選符合條件的元素，並收集成一個新的集合。\n同意詞：filter\n反意詞：reject\np (1..10).select { | x | x \u0026lt; 5} #從數字1到10裡挑選出符合小於 5 的數字，得出[1, 2, 3, 4] p (1..10).reject { | x | x \u0026lt; 5} #從數字1到10裡挑選出不符合小於 5 的數字，得出[5, 6, 7, 8, 9, 10] reduce:對集合裡的每個元素進行運算，並將所有的運算結果歸納成一個單一結果。 同義詞：inject\np (1..10).reduce { |sum, x| sum + x} #1到10的數字會依序丟進 x 裡，再由 sum 負責依序將所有 x 值累加起來，得到 55 範圍 puts (1..10).to_a #印出 1~10 ，to_a轉成陣列 puts (1...10).to_a #印出 1~9 不只可以用在數字上，也可以用在文字上(\u0026quot;a\u0026quot;..\u0026quot;z\u0026quot;)\n與 for 迴圈結合\nfor i in 1..10 puts i end 與 case..when..結合 age = 10 case age when 0..3 puts \u0026#34;嬰兒\u0026#34; when 4..10 puts \u0026#34;兒童\u0026#34; when 11..17 puts \u0026#34;青少年\u0026#34; else puts \u0026#34;成年\u0026#34; end ","permalink":"https://LunaZhuang.github.io/blog/ruby-arrayrange/","tags":["Ruby"],"title":"Ruby 學習筆記-陣列\u0026範圍（Array＆Range）"},{"categories":["Ruby基本功"],"contents":"為什麼要設迴圈？ 因為重複的代碼可以不用一直寫，只要寫好一個迴圈就可以設定他跑十次，最後的結果是一樣的，但可以少寫很多 code。\n迴圈種類 for 迴圈 while 迴圈 loop 迴圈 method 迴圈-Ruby 特有 迭代式迴圈 迴圈與迭代有什麼不同？ 迴圈：不斷的依據指定的條件重複執行某些指令。 迭代：通常會有個對象，針對某個集合的每個元素做某些事。 迴圈寫法 for 迴圈 names = [\u0026#34;eddie\u0026#34;,\u0026#34;joanne\u0026#34;,\u0026#34;john\u0026#34;,\u0026#34;sherly\u0026#34;] for name in names puts name end #設一個變數name一圈一個把names裡面的東西印出來。 for i in 1..10 puts i end while 迴圈(小心變成無窮迴圈，條件設定要設好) x = 0 while x \u0026lt; 10 puts x x += 1 #改變條件 end #一開始x設為0，當x小於10時會印出來0，在印出來後改變條件，變成x=1，一直重複直到x=10。 邪惡分身 until，while not = until\nloop 迴圈(break 一定要設好) i = 0 loop do puts i i += 1 break if i \u0026gt; 10 #break 結束這回合 end #一開始設i為0，先印出來再改變變數,後設條件。 #跟while差在一個先設條件符合條件在執行，loop是你先執行，條件不符在跳出。 do..end或是{}這個叫做 Block(程式碼區塊)\nmethod 式迴圈 5.times do puts \u0026#34;hello,ruby\u0026#34; end #意思是我要印5次hello,ruby。 1.upto(10) do |i| puts \u0026#34;hello,ruby #{i}\u0026#34; end #把數字1到10放進絕對值裡，再帶進${}裡，每次印出hello,ruby時後面的數字會從1到10跟隨印出結束。 10.downto(1) do |i| puts \u0026#34;hello,ruby #{i}\u0026#34; end #把數字10到1放進絕對值裡，再帶進${}裡，每次印出hello,ruby時後面的數字會從10到1跟隨印出結束。 迭代式回圈 names = [\u0026#34;eddie\u0026#34;,\u0026#34;joanne\u0026#34;,\u0026#34;john\u0026#34;,\u0026#34;sherly\u0026#34;] names.each do |name| puts name end #把names裡的元素丟出來給name這個變數，並把它印出來。 names = [\u0026#34;eddie\u0026#34;,\u0026#34;joanne\u0026#34;,\u0026#34;john\u0026#34;,\u0026#34;sherly\u0026#34;] name.each.with_index do |name,x| puts \u0026#34;#{x} #{name}\u0026#34; end #把names裡的每個元素丟出來給name這個變數，再把每個元素的索引值丟給x這個變數，一起印出來。 ","permalink":"https://LunaZhuang.github.io/blog/ruby-loop/","tags":["Ruby"],"title":"Ruby 學習筆記-迴圈與迭代（Loop\u0026Iteration）"},{"categories":["JS入門"],"contents":"為什麼程式語言都需要變數？ 變數只是個名字，只是為了要識別，讓你程式語言在計算的時候，有個放計算資料內容的容器，當你在執行的時候就可以，依照你給他的容器名稱，把他叫出來使用，變數本身沒意義。\n指定又是什麼？ 在程式語言中=(x 等號)而是指定，由右側的值指定給左側的變數名稱。==則是比較兩邊的值。 但在 JavaScript 中==雖然也是比較的意思，不過 JavaScript 會有自動轉型的問題，為了不要讓你的程式碼出現奇怪的內容，建議使用更為嚴謹的===。\n變數的命名 可以使用英文字母或數字，但第一個字不可以是數字。 不能使用保留字 注意英文大小寫有差 保留字 break case catch class const continue debugger default delete do else export extends finally for function if import in instanceof new return super switch this throw try typeof var void while with yield 變數命名需清楚與有意義。 變數名稱慣例 CamelCase(JavaScript) camelCase snake_case(Ruby) 變數有沒有宣告有差嗎？ 有宣告叫變數，沒宣告叫指定。 變數 未定義(undefined) VS 沒有定義(not define) 變數提昇(variable hoisting)與暫時性死區 JavaScript 在瀏覽器執行時會有兩個階段，一個叫建立期(creation phases)另一個是執行期(execution phases)。官網上的說明 建立期 JavaScript 會先將你宣告的變數儲存，再給他一個初始化的值 undefined。\n執行期再按照程式碼逐行執行代碼，將值分配給變量，並執行函數調用。\nES6 後為了要修正 JavaScript 這個問題新增了 let 變數與 const 常數，在 let 與 const 上第一張圖執行結果與 var 變數是相同的，差別在與第二張圖，let 與 const 多了一個叫 TDZ(暫時死區)，執行後的結果會有所差異，請看下圖。 範圍鏈(Scope chain) 從上圖可知在 function 裡的 var 變數不會影響到外部程式，可在 if 身上會影響到外面的 console.log(a)，代表 var 是 function scope。\n同理從上圖可知 function 裡的 let 變數不會影響到外部程式，在 if 身上也不會影響到外面的 console.log(a)，代表 let 是 block scope{}。\nlet,const,var 怎麼選擇？ 能用 const 就用 const，不能用 const 就改用 let var 也可以用，只是它的範圍(Scope)比較大一些 千萬不要沒宣告就拿來用，那會造成全域物件的污染 var let/const Scope function scope block scope{} 重複宣告 可 不可 可能會造成全域屬性 會 不會 變數提昇 有 有(被 TDZ 罩住) JavaScript 2 種型別 原始型別 數字 (Number) 字串 (String) 真假值 (Boolean) 空值 (Null) 未定義 (Undefined) 符號 (Symbol) 物件型別 陣列(Array) 函數(Function) 物件(Object) 對 JavaScript 來說，false,0,\u0026quot;\u0026quot;,undefind,null 都是假的，其餘為真。 ","permalink":"https://LunaZhuang.github.io/blog/js-variableconstant/","tags":["JavaScript"],"title":"JavaScript-變數與常數"},{"categories":["HTML"],"contents":"關於網頁的組成 在網頁開發中最基本有三大元素：HTML、CSS、JavaScript。HTML 就是先將資料結構化，並給於資料標記分類。寫網頁中最主要的就是網頁內容，網頁內容就是我們要呈現的資料，網頁製作是將這些資料使用正確的 HTML 語法將資料標記起來。\n在 HTML 上標記標籤的方式是使用 \u0026lt;起始標籤\u0026gt;內容\u0026lt;/結束標籤\u0026gt; 的方式標記。 \u0026lt;\u0026gt; 這是標籤，裡面會有 \u0026lt;元素\u0026gt;，元素是告訴瀏覽器我這個標籤裡是什麼種類的資料，像是下圖我用 \u0026lt; p \u0026gt; 告訴他這是一段文字內容，網頁上就會呈現出來。\n在元素裡還可以放\u0026lt; p 屬性\u0026gt;\n屬性的組成包含： 在元素名稱和屬性之間有一個空格（如果有多個屬性，屬性之間也需要有空格）。 屬性名稱後面接著等於符號「=」。 屬性包在起始標籤裡面，如上圖所示。 網頁是由眾多標籤元素合在一起像是下圖(MDN 標籤元素大全) 寫網頁要清楚你的這個網頁的重點是什麼，才知道你的網頁要用什麼標籤撰寫。HTML 語意最重要，視覺外觀不是重點。 ","permalink":"https://LunaZhuang.github.io/blog/html/","tags":["HTML"],"title":"HTML(超文本標記語言) "},{"categories":["Ruby基本功"],"contents":"1.等號判斷 a =10 b = \u0026#34;10\u0026#34; p a == b #false p a === b #false 一個等號是指代的意思，二個等號與三個等號都是比較的意思。\n在 JS 上a == b，兩個等號會自動轉型，結果會回傳 true。\n2.如果判斷式 if time = \u0026#34;早上\u0026#34; if time == \u0026#34;早上\u0026#34; puts \u0026#34;好想賴床\u0026#34; end #條件成立的話 if 倒裝句 puts \u0026#34;好想賴床\u0026#34; if time == \u0026#34;早上\u0026#34; #與上面結果相同 unless = if not / if = unless not time = \u0026#34;晚上\u0026#34; if not time == \u0026#34;早上\u0026#34; puts \u0026#34;熬夜追劇！\u0026#34; end #與下列程式相等 unless time == \u0026#34;早上\u0026#34; puts \u0026#34;熬夜追劇！\u0026#34; end unless 倒裝句 puts \u0026#34;熬夜追劇！\u0026#34; unless time == \u0026#34;早上\u0026#34; 不要為了 unless 而 unless，先看自己看不看得懂，以自己能懂為最主要，可以寫 if not 。 if..else.. 二分法 time = \u0026#34;早上\u0026#34; if time == \u0026#34;早上\u0026#34; puts \u0026#34;好想賴床\u0026#34; else puts \u0026#34;熬夜追劇！\u0026#34; end 三元運算子 age = 19 if age \u0026gt;= 19 status = \u0026#34;已成年\u0026#34; else status = \u0026#34;未成年\u0026#34; end ##與下列程式相等 status = (age\u0026gt;=18) ? \u0026#34;已成年\u0026#34;:\u0026#34;未成年\u0026#34; 3.更多條件 if..elsif..else.. time = \u0026#34;早上\u0026#34; if time == \u0026#34;早上\u0026#34; puts \u0026#34;好想賴床\u0026#34; elsif time == \u0026#34;晚上\u0026#34; puts \u0026#34;熬夜追劇！\u0026#34; else puts \u0026#34;睡午覺\u0026#34; end case..when.. time = \u0026#34;早上\u0026#34; case time when \u0026#34;早上\u0026#34; puts \u0026#34;好想賴床\u0026#34; when \u0026#34;晚上\u0026#34; puts \u0026#34;熬夜追劇！\u0026#34; else puts \u0026#34;睡午覺\u0026#34; end ","permalink":"https://LunaZhuang.github.io/blog/ruby-logic/","tags":["Ruby"],"title":"Ruby 學習筆記-邏輯判斷"},{"categories":["Ruby基本功"],"contents":"1.字串的串接 2.字串引號種類 名稱 引號 範例 雙引號 \u0026quot; \u0026quot; puts \u0026ldquo;Hi\u0026rdquo; 單引號 \u0026rsquo; ' puts \u0026lsquo;Hi\u0026rsquo; 跳脫字元 \u0026rsquo; \\ ' puts \u0026lsquo;Hi, I'm Luna\u0026rsquo; 效果等於雙引號 %Q puts %Q(Hi) 效果等於單引號 %q puts %q(Hi) 3.數字-整數與浮點數 puts 3.55.round # 轉成整數，四捨五入 puts 3.74.floor # 轉成整數，無條件捨去 puts 3.14.ceil # 轉成整數，無條件進位 puts 3.14.to_i # 轉成整數，無條件捨去 4.除法 puts 10/3 # 整數除以整數得到3 puts 10.0/3 # 3.33333333 puts 10/3.0 # 3.33333333 puts 10.0/3.0 # 3.33333333 ","permalink":"https://LunaZhuang.github.io/blog/ruby-stringandnumber/","tags":["Ruby"],"title":"Ruby 學習筆記-字串＆數字（String\u0026Number）"},{"categories":["Ruby基本功"],"contents":"1.Ruby 變數種類 2.變數指定 a = a + 2 一個等號是指定 也可以寫成這樣 3.變數多重指定 a.可以利用 Ruby 變數多重指定特性寫成這樣 x,y,z = 1,2,3\nb.如果等號的右邊是陣列也可以自動拆解出來 x,y,z = [1,2,3]\n4.變數的命名慣例 Ruby 世界裡有不成文規定 是使用小寫英文字母以及底線來組合變數名稱，例如像是 my_shopping_cart，稱之蛇形命名法（Snake Case）。 5.常數命名 常數必須要是大寫英文字母開頭 Luna = 1 在寫程式時需要給變數一個好名字 具有清楚與有意義(給 x,y,z 不能使人清楚這段程式碼在寫什麼) 變數與常數就像標籤本身沒有型態 可以把它想像成是「一張有寫著名字的標籤，貼在某個東西上面」，被貼的那個東西有形態，但標籤本身沒有。 ","permalink":"https://LunaZhuang.github.io/blog/ruby-variable/","tags":["Ruby"],"title":"Ruby 學習筆記-變數＆常數（Variable）"},{"categories":["Ruby基本功"],"contents":"Ruby 裡的符號＝有名字的物件（值） 與數字１,2,3 一樣都是有固定的值並不能改變\n１就是１，２就是２\n符號 ：name ，就是：name 不是變數不可以改變他的值\n字串 name=\u0026quot;amber\u0026quot;，name 變數指向一個字串，並可以改變字串內容\n總結：字串與符號的差別 １．字串的內容可以變，但符號不行\n２．字串的效能稍微差一點點\n","permalink":"https://LunaZhuang.github.io/blog/ruby-symbol/","tags":["Ruby"],"title":"Ruby 學習筆記-符號（Symbol）"}]